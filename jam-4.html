<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Phase 4 Jam: The Polyphonic Performance Rack</title>
    <link rel="stylesheet" href="shared/elements.css" />
    <link rel="stylesheet" href="shared/synth-ui.css" />
    <style>
      body { max-width: 960px; margin: 0 auto; padding: 10px; padding-bottom: 40px; }
      .top-bar { position: sticky; top: 0; background: #f5f5f5; border: 1px solid #ccc; padding: 10px; z-index: 100; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
      .keyboard { position: relative; height: 120px; margin-top: 10px; user-select: none; overflow: hidden; }
      .key { position: absolute; top: 0; bottom: 0; border: 1px solid #333; background: #fff; cursor: pointer; z-index: 1; border-radius: 0 0 4px 4px; }
      .key.black { background: #333; color: #fff; height: 65%; z-index: 2; border-radius: 0 0 3px 3px; }
      .key.active { background: #07a; }
      .key.black.active { background: #059; }
      .key-label { position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); font-size: 10px; pointer-events: none; }
      .kb-hint { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); font-size: 9px; pointer-events: none; color: #999; }
      .key.black .kb-hint { color: #aaa; bottom: auto; top: 42px; }
      /* Sequencer */
      .seq-section { margin-top: 10px; border: 1px solid #ccc; padding: 8px; background: #f9f9f9; }
      .seq-section h3 { margin: 0 0 6px 0; font-size: 13px; border-bottom: 1px solid #ccc; padding-bottom: 4px; }
      .seq-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; }
      .seq-controls button { padding: 4px 12px; font-size: 13px; cursor: pointer; }
      .seq-controls label { display: flex; align-items: center; gap: 5px; font-size: 12px; font-weight: bold; }
      .seq-controls input[type="range"] { width: 80px; }
      .seq-controls .val { font-family: monospace; min-width: 35px; text-align: right; }
      .seq-grid-wrap { overflow-x: auto; }
      .seq-grid { display: flex; gap: 2px; margin-bottom: 3px; min-width: fit-content; }
      .seq-cell { width: 36px; min-width: 36px; height: 22px; background: #ddd; border: 1px solid #aaa; cursor: pointer; position: relative; font-size: 8px; text-align: center; line-height: 22px; user-select: none; }
      .seq-cell.on { background: #07a; color: #fff; }
      .seq-cell.playing { box-shadow: inset 0 0 0 2px #f80; }
    </style>
  </head>
  <body>
    <div class="init-bar">
      <strong>ðŸŽ¹ Polyphonic Performance Rack</strong>
      <span>
        <button id="init-audio">Start Audio</button>
        <span id="audio-status" style="color: red; font-size: 12px">Stopped</span>
      </span>
    </div>

    <!-- ON-SCREEN KEYBOARD (absolute positioned for proper piano layout) -->
    <div class="keyboard" id="keyboard"></div>

    <!-- STICKY ARPEGGIATOR BAR -->
    <div class="top-bar">
      <div class="transport">
        <button id="btn-arp-toggle">Arp: OFF</button>
        <label title="Arpeggiator rate in Hz.">Rate
          <input type="range" id="in-arp-rate" min="1" max="20" step="0.5" value="6" />
          <span class="val" id="val-arp-rate">6</span>
        </label>
        <label title="Arpeggiator pattern.">Pattern
          <select id="sel-arp-pattern" style="font-size: 12px; padding: 2px;">
            <option value="up">Up</option>
            <option value="down">Down</option>
            <option value="updown">Up-Down</option>
            <option value="random">Random</option>
          </select>
        </label>
      </div>
    </div>

    <!-- STEP SEQUENCER -->
    <div class="seq-section" id="seq-section">
      <h3>Step Sequencer</h3>
      <div class="seq-controls">
        <button id="btn-seq-play">â–¶ Play</button>
        <button id="btn-seq-stop">â–  Stop</button>
        <button id="btn-seq-clear">Clear</button>
        <label title="Sequencer tempo in BPM.">BPM
          <input type="range" id="in-seq-bpm" min="60" max="240" step="1" value="120" />
          <span class="val" id="val-seq-bpm">120</span>
        </label>
        <label title="Number of steps in the sequence.">Steps
          <select id="sel-seq-steps" style="font-size: 12px; padding: 2px;">
            <option value="8">8</option>
            <option value="16" selected>16</option>
            <option value="32">32</option>
          </select>
        </label>
      </div>
      <div class="seq-grid-wrap" id="seq-grid-wrap"></div>
    </div>

    <!-- SCOPES -->
    <div class="scope-row">
      <div class="scope-wrap">
        <span class="scope-label">WAVEFORM</span>
        <canvas id="scope-wave"></canvas>
      </div>
      <div class="scope-wrap">
        <span class="scope-label">FREQUENCY</span>
        <canvas id="scope-freq"></canvas>
      </div>
    </div>

    <!-- PANELS -->
    <div class="panels">
      <!-- OSCILLATOR -->
      <div class="panel" id="panel-osc">
        <h3>Oscillator</h3>
        <div class="knob">
          <label title="Oscillator waveform shape.">Waveform <span class="val" id="val-osc-wave">sawtooth</span></label>
          <select id="in-osc-wave" style="width:100%; font-size:11px;">
            <option value="sawtooth">Sawtooth</option>
            <option value="square">Square</option>
            <option value="triangle">Triangle</option>
            <option value="sine">Sine</option>
          </select>
        </div>
        <div class="knob">
          <label title="Detune amount in cents. Adds thickness by detuning oscillators slightly.">Detune <span class="val" id="val-osc-detune">0</span></label>
          <input type="range" id="in-osc-detune" min="-50" max="50" step="1" value="0" />
        </div>
      </div>

      <!-- FILTER -->
      <div class="panel" id="panel-flt">
        <h3>Filter</h3>
        <div class="knob">
          <label title="Lowpass filter cutoff frequency.">Cutoff <span class="val" id="val-flt-cut">2000</span></label>
          <input type="range" id="in-flt-cut" min="50" max="8000" value="2000" />
        </div>
        <div class="knob">
          <label title="Filter resonance. Boosts frequencies at the cutoff point.">Resonance <span class="val" id="val-flt-res">1</span></label>
          <input type="range" id="in-flt-res" min="0" max="25" step="0.5" value="1" />
        </div>
      </div>

      <!-- ENVELOPE -->
      <div class="panel" id="panel-env">
        <h3>Envelope</h3>
        <div class="knob">
          <label title="Attack time. How fast the sound fades in.">Attack <span class="val" id="val-env-atk">0.01</span></label>
          <input type="range" id="in-env-atk" min="0.005" max="2.0" step="0.005" value="0.01" />
        </div>
        <div class="knob">
          <label title="Decay time. Fade from peak to sustain level.">Decay <span class="val" id="val-env-dec">0.20</span></label>
          <input type="range" id="in-env-dec" min="0.01" max="2.0" step="0.01" value="0.20" />
        </div>
        <div class="knob">
          <label title="Sustain level while key is held. 0 = pluck. 1 = organ.">Sustain <span class="val" id="val-env-sus">0.60</span></label>
          <input type="range" id="in-env-sus" min="0" max="1" step="0.01" value="0.60" />
        </div>
        <div class="knob">
          <label title="Release time. Fade-out after key is released.">Release <span class="val" id="val-env-rel">0.30</span></label>
          <input type="range" id="in-env-rel" min="0.01" max="3.0" step="0.01" value="0.30" />
        </div>
      </div>

      <!-- MOD / FX -->
      <div class="panel" id="panel-modfx">
        <h3>Mod / FX</h3>
        <div class="knob">
          <label title="Mod 1 LFO rate (Hz). Modulates filter cutoff.">Mod1 Rate <span class="val" id="val-mod1-rate">0</span></label>
          <input type="range" id="in-mod1-rate" min="0" max="15" step="0.1" value="0" />
        </div>
        <div class="knob">
          <label title="Mod 1 depth. How much the LFO sweeps the filter cutoff.">Mod1 Depth <span class="val" id="val-mod1-depth">0</span></label>
          <input type="range" id="in-mod1-depth" min="0" max="4000" step="10" value="0" />
        </div>
        <div class="knob">
          <label title="Mod 2 LFO rate (Hz). Modulates wavefolder amount.">Mod2 Rate <span class="val" id="val-mod2-rate">0</span></label>
          <input type="range" id="in-mod2-rate" min="0" max="15" step="0.1" value="0" />
        </div>
        <div class="knob">
          <label title="Mod 2 depth. How much the LFO affects the wavefolder intensity.">Mod2 Depth <span class="val" id="val-mod2-depth">0</span></label>
          <input type="range" id="in-mod2-depth" min="0" max="1" step="0.01" value="0" />
        </div>
        <div class="knob">
          <label title="Delay time in seconds.">Delay Time <span class="val" id="val-dly-time">0.30</span></label>
          <input type="range" id="in-dly-time" min="0.05" max="1.0" step="0.01" value="0.30" />
        </div>
        <div class="knob">
          <label title="Delay feedback. Higher = longer echoes.">Delay FB <span class="val" id="val-dly-fb">0.30</span></label>
          <input type="range" id="in-dly-fb" min="0" max="0.85" step="0.01" value="0.30" />
        </div>
        <div class="knob">
          <label title="Delay dry/wet mix. 0 = no delay. 1 = delay only.">Delay Mix <span class="val" id="val-dly-mix">0.20</span></label>
          <input type="range" id="in-dly-mix" min="0" max="1" step="0.01" value="0.20" />
        </div>
      </div>

      <!-- MASTER -->
      <div class="panel" id="panel-master">
        <h3>Master</h3>
        <div class="knob">
          <label title="Master output volume.">Volume <span class="val" id="val-master">0.50</span></label>
          <input type="range" id="in-master" min="0" max="1" step="0.01" value="0.50" />
        </div>
      </div>
    </div>

    <script>
      // ========== AUDIO ENGINE ==========
      let ctx;
      let isReady = false;

      document.getElementById("init-audio").addEventListener("click", async () => {
        if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (ctx.state === "suspended") await ctx.resume();
        isReady = true;
        document.getElementById("audio-status").innerText = "Running";
        document.getElementById("audio-status").style.color = "green";
        document.getElementById("init-audio").disabled = true;
        buildEngine();
      });

      // ========== HELPERS ==========
      function gv(id) { return parseFloat(document.getElementById(id).value); }

      function bind(sId, dId, cb) {
        const s = document.getElementById(sId);
        const d = document.getElementById(dId);
        s.addEventListener("input", () => {
          d.innerText = s.value;
          if (cb) cb(parseFloat(s.value));
        });
      }

      // ========== NOTE FREQUENCIES ==========
      const NOTE_FREQS = {
        "C3": 130.81, "C#3": 138.59, "D3": 146.83, "D#3": 155.56,
        "E3": 164.81, "F3": 174.61, "F#3": 185.00, "G3": 196.00,
        "G#3": 207.65, "A3": 220.00, "A#3": 233.08, "B3": 246.94,
        "C4": 261.63
      };

      const NOTE_NAMES = Object.keys(NOTE_FREQS);

      // ========== BUILD PIANO KEYBOARD (responsive, absolute positioning) ==========
      const KEY_MAP = {
        "a": "C3", "w": "C#3", "s": "D3", "e": "D#3", "d": "E3",
        "f": "F3", "t": "F#3", "g": "G3", "y": "G#3", "h": "A3",
        "u": "A#3", "j": "B3", "k": "C4"
      };
      const KEY_MAP_DISPLAY = {};
      for (const [k, v] of Object.entries(KEY_MAP)) KEY_MAP_DISPLAY[v] = k.toUpperCase();

      function buildKeyboard() {
        const kb = document.getElementById("keyboard");
        kb.innerHTML = "";

        // White keys: C D E F G A B C (8 keys)
        const whiteNotes = NOTE_NAMES.filter(n => !n.includes("#"));
        const totalWhite = whiteNotes.length; // 8

        // Black key positions relative to their preceding white key
        // In a C-major octave: C#(after C), D#(after D), F#(after F), G#(after G), A#(after A)
        const blackNotes = NOTE_NAMES.filter(n => n.includes("#"));
        const blackAfterWhite = { "C#3": 0, "D#3": 1, "F#3": 3, "G#3": 4, "A#3": 5 };

        const whiteWidthPct = 100 / totalWhite;
        const blackWidthPct = whiteWidthPct * 0.6;

        // Create white keys
        whiteNotes.forEach((note, i) => {
          const el = document.createElement("div");
          el.className = "key";
          el.dataset.note = note;
          el.style.left = (i * whiteWidthPct) + "%";
          el.style.width = whiteWidthPct + "%";
          el.innerHTML = '<span class="key-label">' + note + '</span>'
            + (KEY_MAP_DISPLAY[note] ? '<span class="kb-hint">' + KEY_MAP_DISPLAY[note] + '</span>' : '');
          kb.appendChild(el);
        });

        // Create black keys
        blackNotes.forEach(note => {
          const whiteIdx = blackAfterWhite[note];
          if (whiteIdx === undefined) return;
          const el = document.createElement("div");
          el.className = "key black";
          el.dataset.note = note;
          el.style.left = ((whiteIdx + 1) * whiteWidthPct - blackWidthPct / 2) + "%";
          el.style.width = blackWidthPct + "%";
          el.innerHTML = '<span class="key-label">' + note.replace("3", "") + '</span>'
            + (KEY_MAP_DISPLAY[note] ? '<span class="kb-hint">' + KEY_MAP_DISPLAY[note] + '</span>' : '');
          kb.appendChild(el);
        });
      }
      buildKeyboard();

      // ========== POLYPHONIC VOICE POOL ==========
      const NUM_VOICES = 4;
      let voices = [];
      let voiceIndex = 0;
      let masterGain, analyser;
      let delayNode, delayFb, dryGain, wetGain;
      let lfo1, lfo1Gain, lfo2, lfo2Gain;
      let wavefolder;
      let foldBaseGain;

      function makeWavefoldCurve(amount) {
        const n = 8192, curve = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = Math.sin(x * Math.PI * amount);
        }
        return curve;
      }

      function buildEngine() {
        // Master chain
        masterGain = ctx.createGain();
        masterGain.gain.value = gv("in-master");
        analyser = ctx.createAnalyser();
        analyser.fftSize = 2048;

        // Delay effect
        delayNode = ctx.createDelay(2);
        delayNode.delayTime.value = gv("in-dly-time");
        delayFb = ctx.createGain();
        delayFb.gain.value = gv("in-dly-fb");
        dryGain = ctx.createGain();
        dryGain.gain.value = 1 - gv("in-dly-mix");
        wetGain = ctx.createGain();
        wetGain.gain.value = gv("in-dly-mix");

        // Delay routing
        const delayBus = ctx.createGain();
        delayBus.gain.value = 1;
        delayBus.connect(dryGain).connect(masterGain);
        delayBus.connect(delayNode);
        delayNode.connect(delayFb).connect(delayNode);
        delayNode.connect(wetGain).connect(masterGain);
        masterGain.connect(analyser).connect(ctx.destination);

        // Wavefolder (shared)
        wavefolder = ctx.createWaveShaper();
        wavefolder.curve = makeWavefoldCurve(2);
        wavefolder.oversample = "4x";

        // Fold amount gain (pre-waveshaper drive)
        foldBaseGain = ctx.createGain();
        foldBaseGain.gain.value = 1;
        foldBaseGain.connect(wavefolder);
        wavefolder.connect(delayBus);

        // LFO 1 â†’ Filter cutoff (applied per-voice filter)
        lfo1 = ctx.createOscillator();
        lfo1.type = "sine";
        lfo1.frequency.value = gv("in-mod1-rate");
        lfo1Gain = ctx.createGain();
        lfo1Gain.gain.value = gv("in-mod1-depth");
        lfo1.connect(lfo1Gain);
        lfo1.start();

        // LFO 2 â†’ Fold amount (modulates foldBaseGain)
        lfo2 = ctx.createOscillator();
        lfo2.type = "sine";
        lfo2.frequency.value = gv("in-mod2-rate");
        lfo2Gain = ctx.createGain();
        lfo2Gain.gain.value = gv("in-mod2-depth");
        lfo2.connect(lfo2Gain);
        lfo2Gain.connect(foldBaseGain.gain);
        lfo2.start();

        // Build 4 polyphonic voices
        const waveform = document.getElementById("in-osc-wave").value;
        const detune = gv("in-osc-detune");
        const cutoff = gv("in-flt-cut");
        const reso = gv("in-flt-res");

        for (let i = 0; i < NUM_VOICES; i++) {
          const osc = ctx.createOscillator();
          osc.type = waveform;
          osc.frequency.value = 130.81;
          osc.detune.value = detune;

          const filter = ctx.createBiquadFilter();
          filter.type = "lowpass";
          filter.frequency.value = cutoff;
          filter.Q.value = reso;

          // Connect LFO1 to each voice's filter
          lfo1Gain.connect(filter.frequency);

          const vca = ctx.createGain();
          vca.gain.value = 0;

          osc.connect(filter);
          filter.connect(vca);
          vca.connect(foldBaseGain);

          osc.start();

          voices.push({
            osc: osc,
            filter: filter,
            vca: vca,
            note: null,
            active: false
          });
        }

        drawScope();
      }

      // ========== NOTE TRIGGER / RELEASE ==========
      function triggerVoice(note) {
        if (!isReady || voices.length === 0) return;
        const freq = NOTE_FREQS[note];
        if (!freq) return;

        // Check if this note is already playing on a voice
        for (let i = 0; i < NUM_VOICES; i++) {
          if (voices[i].note === note && voices[i].active) return;
        }

        // Round-robin allocation
        const v = voices[voiceIndex % NUM_VOICES];
        voiceIndex++;

        const now = ctx.currentTime;
        const atk = gv("in-env-atk");
        const dec = gv("in-env-dec");
        const sus = gv("in-env-sus");

        v.osc.frequency.setValueAtTime(freq, now);
        v.osc.type = document.getElementById("in-osc-wave").value;
        v.osc.detune.setValueAtTime(gv("in-osc-detune"), now);

        v.filter.frequency.setValueAtTime(gv("in-flt-cut"), now);
        v.filter.Q.value = gv("in-flt-res");

        // ADSR: Attack â†’ Decay â†’ Sustain
        v.vca.gain.cancelScheduledValues(now);
        v.vca.gain.setValueAtTime(0, now);
        v.vca.gain.linearRampToValueAtTime(1.0, now + atk);
        v.vca.gain.linearRampToValueAtTime(Math.max(0.001, sus), now + atk + dec);

        v.note = note;
        v.active = true;
      }

      function releaseVoice(note) {
        if (!isReady || voices.length === 0) return;
        const now = ctx.currentTime;
        const rel = gv("in-env-rel");

        for (let i = 0; i < NUM_VOICES; i++) {
          if (voices[i].note === note && voices[i].active) {
            voices[i].vca.gain.cancelScheduledValues(now);
            voices[i].vca.gain.setValueAtTime(voices[i].vca.gain.value, now);
            voices[i].vca.gain.linearRampToValueAtTime(0, now + rel);
            voices[i].active = false;
            voices[i].note = null;
          }
        }
      }

      // ========== KEYBOARD INTERACTION ==========
      const heldNotes = new Set();

      function getKeyElements() { return document.querySelectorAll(".key"); }

      function noteOn(note) {
        if (heldNotes.has(note)) return;
        heldNotes.add(note);
        triggerVoice(note);
        updateKeyHighlights();
        if (arpEnabled && !arpTimerId) startArp();
      }

      function noteOff(note) {
        if (!heldNotes.has(note)) return;
        heldNotes.delete(note);
        if (!arpEnabled) {
          releaseVoice(note);
        }
        updateKeyHighlights();
        if (arpEnabled && heldNotes.size === 0) stopArp();
      }

      function updateKeyHighlights() {
        getKeyElements().forEach(el => {
          const n = el.dataset.note;
          if (heldNotes.has(n)) el.classList.add("active");
          else el.classList.remove("active");
        });
      }

      // Mouse events (use event delegation on keyboard container)
      const kbEl = document.getElementById("keyboard");
      kbEl.addEventListener("mousedown", (e) => {
        const el = e.target.closest(".key");
        if (el) { e.preventDefault(); noteOn(el.dataset.note); }
      });
      document.addEventListener("mouseup", () => {
        // Release all mouse-held notes when mouse is released anywhere
        for (const note of [...heldNotes]) {
          if (!pcKeysDown.has(Object.entries(KEY_MAP).find(([k, v]) => v === note)?.[0])) {
            noteOff(note);
          }
        }
      });
      kbEl.addEventListener("mouseover", (e) => {
        if (e.buttons > 0) {
          const el = e.target.closest(".key");
          if (el) noteOn(el.dataset.note);
        }
      });
      kbEl.addEventListener("mouseout", (e) => {
        if (e.buttons > 0) {
          const el = e.target.closest(".key");
          if (el) noteOff(el.dataset.note);
        }
      });

      // Touch events
      kbEl.addEventListener("touchstart", (e) => {
        e.preventDefault();
        for (const t of e.changedTouches) {
          const el = document.elementFromPoint(t.clientX, t.clientY);
          if (el && el.closest && el.closest(".key")) noteOn(el.closest(".key").dataset.note);
        }
      }, { passive: false });

      kbEl.addEventListener("touchend", (e) => {
        e.preventDefault();
        for (const t of e.changedTouches) {
          const el = document.elementFromPoint(t.clientX, t.clientY);
          if (el && el.closest && el.closest(".key")) noteOff(el.closest(".key").dataset.note);
        }
      }, { passive: false });

      // ========== PC KEYBOARD SUPPORT ==========
      const pcKeysDown = new Set();
      document.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        const note = KEY_MAP[e.key.toLowerCase()];
        if (note) {
          e.preventDefault();
          pcKeysDown.add(e.key.toLowerCase());
          noteOn(note);
        }
      });
      document.addEventListener("keyup", (e) => {
        const note = KEY_MAP[e.key.toLowerCase()];
        if (note) {
          e.preventDefault();
          pcKeysDown.delete(e.key.toLowerCase());
          noteOff(note);
        }
      });

      // ========== ARPEGGIATOR ==========
      let arpEnabled = false;
      let arpTimerId = null;
      let arpDirection = 1; // 1=up, -1=down (for up-down mode)
      let arpIndex = 0;

      document.getElementById("btn-arp-toggle").addEventListener("click", () => {
        arpEnabled = !arpEnabled;
        document.getElementById("btn-arp-toggle").textContent = arpEnabled ? "Arp: ON" : "Arp: OFF";
        if (arpEnabled && heldNotes.size > 0) {
          startArp();
        } else {
          stopArp();
        }
      });

      function getSortedHeldNotes() {
        const noteOrder = Object.keys(NOTE_FREQS);
        return [...heldNotes].sort((a, b) => noteOrder.indexOf(a) - noteOrder.indexOf(b));
      }

      function arpTick() {
        const sorted = getSortedHeldNotes();
        if (sorted.length === 0) { stopArp(); return; }

        const pattern = document.getElementById("sel-arp-pattern").value;
        let note;

        if (pattern === "random") {
          note = sorted[Math.floor(Math.random() * sorted.length)];
        } else if (pattern === "up") {
          arpIndex = arpIndex % sorted.length;
          note = sorted[arpIndex];
          arpIndex++;
        } else if (pattern === "down") {
          arpIndex = arpIndex % sorted.length;
          note = sorted[sorted.length - 1 - arpIndex];
          arpIndex++;
        } else if (pattern === "updown") {
          if (sorted.length === 1) {
            note = sorted[0];
          } else {
            if (arpIndex >= sorted.length) {
              arpDirection = -1;
              arpIndex = sorted.length - 2;
            }
            if (arpIndex < 0) {
              arpDirection = 1;
              arpIndex = 1;
            }
            arpIndex = Math.max(0, Math.min(sorted.length - 1, arpIndex));
            note = sorted[arpIndex];
            arpIndex += arpDirection;
          }
        }

        // Release all voices then trigger the arp note
        for (let i = 0; i < NUM_VOICES; i++) {
          if (voices[i].active) {
            const now = ctx.currentTime;
            voices[i].vca.gain.cancelScheduledValues(now);
            voices[i].vca.gain.setValueAtTime(voices[i].vca.gain.value, now);
            voices[i].vca.gain.linearRampToValueAtTime(0, now + 0.01);
            voices[i].active = false;
            voices[i].note = null;
          }
        }

        if (note) {
          // Directly trigger without the heldNotes check
          const freq = NOTE_FREQS[note];
          if (freq && voices.length > 0) {
            const v = voices[voiceIndex % NUM_VOICES];
            voiceIndex++;
            const now = ctx.currentTime;
            const atk = gv("in-env-atk");
            const dec = gv("in-env-dec");
            const sus = gv("in-env-sus");

            v.osc.frequency.setValueAtTime(freq, now);
            v.osc.type = document.getElementById("in-osc-wave").value;
            v.osc.detune.setValueAtTime(gv("in-osc-detune"), now);
            v.filter.frequency.setValueAtTime(gv("in-flt-cut"), now);
            v.filter.Q.value = gv("in-flt-res");

            v.vca.gain.cancelScheduledValues(now);
            v.vca.gain.setValueAtTime(0, now);
            v.vca.gain.linearRampToValueAtTime(1.0, now + atk);
            v.vca.gain.linearRampToValueAtTime(Math.max(0.001, sus), now + atk + dec);

            v.note = note;
            v.active = true;
          }
        }
      }

      function startArp() {
        stopArp();
        arpIndex = 0;
        arpDirection = 1;
        const rate = gv("in-arp-rate");
        const intervalMs = 1000 / rate;
        arpTick();
        arpTimerId = setInterval(arpTick, intervalMs);
      }

      function stopArp() {
        if (arpTimerId) {
          clearInterval(arpTimerId);
          arpTimerId = null;
        }
        // Release all voices
        if (voices.length > 0) {
          const now = ctx ? ctx.currentTime : 0;
          for (let i = 0; i < NUM_VOICES; i++) {
            if (voices[i].active) {
              voices[i].vca.gain.cancelScheduledValues(now);
              voices[i].vca.gain.setValueAtTime(voices[i].vca.gain.value, now);
              voices[i].vca.gain.linearRampToValueAtTime(0, now + 0.05);
              voices[i].active = false;
              voices[i].note = null;
            }
          }
        }
      }

      function resyncArp() {
        if (!arpEnabled || !arpTimerId) return;
        startArp();
      }

      // ========== STEP SEQUENCER ==========
      let seqSteps = 16;
      let seqData = []; // seqData[step] = set of note names
      let seqPlaying = false;
      let seqTimerId = null;
      let seqCurrentStep = -1;

      function initSeqData(steps) {
        seqData = [];
        for (let i = 0; i < steps; i++) seqData.push(new Set());
      }
      initSeqData(seqSteps);

      function buildSeqGrid() {
        const wrap = document.getElementById("seq-grid-wrap");
        wrap.innerHTML = "";
        // One row per note (bottom = low, top = high)
        for (let r = NOTE_NAMES.length - 1; r >= 0; r--) {
          const note = NOTE_NAMES[r];
          const row = document.createElement("div");
          row.className = "seq-grid";
          for (let s = 0; s < seqSteps; s++) {
            const cell = document.createElement("div");
            cell.className = "seq-cell" + (seqData[s].has(note) ? " on" : "");
            cell.dataset.step = s;
            cell.dataset.note = note;
            cell.textContent = s === 0 ? note.replace("3", "").replace("4", "") : "";
            cell.addEventListener("mousedown", () => {
              if (seqData[s].has(note)) {
                seqData[s].delete(note);
                cell.classList.remove("on");
              } else {
                seqData[s].add(note);
                cell.classList.add("on");
              }
            });
            row.appendChild(cell);
          }
          wrap.appendChild(row);
        }
      }
      buildSeqGrid();

      function updateSeqHighlight() {
        document.querySelectorAll(".seq-cell.playing").forEach(el => el.classList.remove("playing"));
        if (seqCurrentStep >= 0) {
          document.querySelectorAll('.seq-cell[data-step="' + seqCurrentStep + '"]').forEach(el => el.classList.add("playing"));
        }
      }

      let seqPrevNotes = new Set();
      function seqTick() {
        seqCurrentStep = (seqCurrentStep + 1) % seqSteps;
        updateSeqHighlight();

        // Release notes from previous step that are not in current step
        const currentNotes = seqData[seqCurrentStep];
        for (const note of seqPrevNotes) {
          if (!currentNotes.has(note)) releaseVoice(note);
        }
        // Trigger notes in current step
        for (const note of currentNotes) {
          if (!seqPrevNotes.has(note)) {
            triggerVoice(note);
          }
        }
        seqPrevNotes = new Set(currentNotes);
      }

      function startSeq() {
        if (!isReady) return;
        stopSeq();
        seqPlaying = true;
        seqCurrentStep = -1;
        seqPrevNotes = new Set();
        const bpm = gv("in-seq-bpm");
        const intervalMs = 60000 / bpm / 4; // 16th notes
        seqTick();
        seqTimerId = setInterval(seqTick, intervalMs);
      }

      function stopSeq() {
        seqPlaying = false;
        if (seqTimerId) {
          clearInterval(seqTimerId);
          seqTimerId = null;
        }
        // Release all seq notes
        for (const note of seqPrevNotes) releaseVoice(note);
        seqPrevNotes = new Set();
        seqCurrentStep = -1;
        updateSeqHighlight();
      }

      document.getElementById("btn-seq-play").addEventListener("click", () => {
        if (!isReady) return alert("Start Audio first");
        startSeq();
      });
      document.getElementById("btn-seq-stop").addEventListener("click", stopSeq);
      document.getElementById("btn-seq-clear").addEventListener("click", () => {
        stopSeq();
        initSeqData(seqSteps);
        buildSeqGrid();
      });

      document.getElementById("sel-seq-steps").addEventListener("change", (e) => {
        const newSteps = parseInt(e.target.value);
        const wasPlaying = seqPlaying;
        stopSeq();
        // Preserve existing data
        const oldData = seqData;
        seqSteps = newSteps;
        initSeqData(seqSteps);
        for (let s = 0; s < Math.min(oldData.length, seqSteps); s++) {
          seqData[s] = oldData[s];
        }
        buildSeqGrid();
        if (wasPlaying) startSeq();
      });

      bind("in-seq-bpm", "val-seq-bpm", () => {
        if (seqPlaying) startSeq(); // restart with new tempo
      });

      // ========== SCOPE ==========
      function syncCanvasSize(canvas) {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const w = Math.round(rect.width * dpr);
        const h = Math.round(rect.height * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }
      }

      function drawScope() {
        if (!analyser) return;
        const waveCanvas = document.getElementById("scope-wave");
        const freqCanvas = document.getElementById("scope-freq");
        const wc = waveCanvas.getContext("2d");
        const fc = freqCanvas.getContext("2d");
        const bufLen = analyser.frequencyBinCount;
        const timeBuf = new Uint8Array(bufLen);
        const freqBuf = new Uint8Array(bufLen);

        function render() {
          requestAnimationFrame(render);
          syncCanvasSize(waveCanvas);
          syncCanvasSize(freqCanvas);

          analyser.getByteTimeDomainData(timeBuf);
          const ww = waveCanvas.width, wh = waveCanvas.height;
          wc.fillStyle = "#fff";
          wc.fillRect(0, 0, ww, wh);
          wc.strokeStyle = "#ddd";
          wc.lineWidth = 1;
          wc.beginPath();
          wc.moveTo(0, wh / 2);
          wc.lineTo(ww, wh / 2);
          wc.stroke();
          wc.lineWidth = 1.5;
          wc.strokeStyle = "#07a";
          wc.beginPath();
          const sliceW = ww / bufLen;
          for (let i = 0; i < bufLen; i++) {
            const y = (timeBuf[i] / 255) * wh;
            if (i === 0) wc.moveTo(0, y);
            else wc.lineTo(i * sliceW, y);
          }
          wc.stroke();

          analyser.getByteFrequencyData(freqBuf);
          const fw = freqCanvas.width, fh = freqCanvas.height;
          fc.fillStyle = "#fff";
          fc.fillRect(0, 0, fw, fh);
          const barCount = Math.min(bufLen, fw);
          const barW = fw / barCount;
          for (let i = 0; i < barCount; i++) {
            const v = freqBuf[i] / 255;
            const barH = v * fh;
            fc.fillStyle = `hsl(${200 - v * 160}, 70%, ${50 - v * 20}%)`;
            fc.fillRect(i * barW, fh - barH, Math.max(barW - 0.5, 1), barH);
          }
        }
        render();
      }

      // ========== KNOB BINDINGS ==========
      // Oscillator
      document.getElementById("in-osc-wave").addEventListener("input", (e) => {
        document.getElementById("val-osc-wave").innerText = e.target.value;
        voices.forEach(v => { v.osc.type = e.target.value; });
      });
      bind("in-osc-detune", "val-osc-detune", (v) => {
        voices.forEach(voice => { voice.osc.detune.value = v; });
      });

      // Filter
      bind("in-flt-cut", "val-flt-cut", (v) => {
        voices.forEach(voice => { voice.filter.frequency.value = v; });
      });
      bind("in-flt-res", "val-flt-res", (v) => {
        voices.forEach(voice => { voice.filter.Q.value = v; });
      });

      // Envelope (read at trigger time, no live binding needed)
      bind("in-env-atk", "val-env-atk");
      bind("in-env-dec", "val-env-dec");
      bind("in-env-sus", "val-env-sus");
      bind("in-env-rel", "val-env-rel");

      // Mod 1 (LFO â†’ Filter)
      bind("in-mod1-rate", "val-mod1-rate", (v) => {
        if (lfo1) lfo1.frequency.value = v;
      });
      bind("in-mod1-depth", "val-mod1-depth", (v) => {
        if (lfo1Gain) lfo1Gain.gain.value = v;
      });

      // Mod 2 (LFO â†’ Fold)
      bind("in-mod2-rate", "val-mod2-rate", (v) => {
        if (lfo2) lfo2.frequency.value = v;
      });
      bind("in-mod2-depth", "val-mod2-depth", (v) => {
        if (lfo2Gain) lfo2Gain.gain.value = v;
      });

      // Delay
      bind("in-dly-time", "val-dly-time", (v) => {
        if (delayNode) delayNode.delayTime.value = v;
      });
      bind("in-dly-fb", "val-dly-fb", (v) => {
        if (delayFb) delayFb.gain.value = v;
      });
      bind("in-dly-mix", "val-dly-mix", (v) => {
        if (dryGain) dryGain.gain.value = 1 - v;
        if (wetGain) wetGain.gain.value = v;
      });

      // Master
      bind("in-master", "val-master", (v) => {
        if (masterGain) masterGain.gain.value = v;
      });

      // Arp rate
      bind("in-arp-rate", "val-arp-rate", () => { resyncArp(); });
    </script>
  </body>
</html>
